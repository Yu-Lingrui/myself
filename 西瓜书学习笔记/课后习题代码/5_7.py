# -*- coding: utf-8 -*-
"""5_7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HcQgKPWBfQKEMHvdBK5cSs4175w-eSP8

# 导包
"""

import random
import numpy as np
import matplotlib.pyplot as plt

"""# 定义超参数"""

d_input = 2 # 输入层神经元个数
d_hidden = 10 # 隐含层神经元个数
d_output = 1 # 输出层神经元个数

lr = 0.05
epochs = 1000

"""# 数据预处理"""

# 异或问题共有四个样本
dataset = [[[1, 1], 0], [[1, 0], 1],
          [[0, 1], 1], [[0, 0], 0]]

"""# 定义模型"""

def sigmoid(x):
    y = []
    for i in x:
       y.append(1 / (1 + np.exp(-i)))
    return np.array(y)

class RBF():
    def __init__(self):
        self.w = np.random.randn(d_hidden, 1)
        self.beta = np.random.randn(d_hidden, 1)
        self.c = np.random.randn(d_hidden, d_input)
    
    def train(self, data, test=False):
        # 读取数据
        x = np.array(data[0]).reshape((1, d_input))
        y = data[1]

        # 预测结果
        dist = np.sum((x - self.c)**2, axis=1, keepdims=True)
        p = np.exp(- self.beta * dist)
        pred = sigmoid(np.dot(self.w.T, p))

        # 计算误差
        loss = 0.5 * (pred - y)*(pred - y)
        
        # 测试时不用更新参数
        if test == False:
            # 计算梯度
            grad_y = pred - y
            grad_w = grad_y * p
            grad_p = grad_y * self.w
            grad_beta = - grad_p * p * dist
            grad_c = grad_p * p * 2 * self.beta * (x - self.c)

            # 更新参数
            self.w = self.w - lr * grad_w
            self.beta = self.beta - lr * grad_beta
            self.c  = self.c - lr * grad_c
        return pred, loss

"""# 训练模型"""

model = RBF()
loss = []
for i in range(epochs):
    lo = []
    random.shuffle(dataset)
    for data in dataset:
        _, l = model.train(data)
        lo.append(l)
    loss.append(np.mean(lo))

"""# 可视化loss"""

plt.figure()
plt.plot(loss[1:])
plt.xlabel('step')
plt.ylabel('loss')
plt.show()
print(loss)

"""# 预测"""

label, predy = [], []
for data in dataset:
    pred, _ = model.train(data, test=True)
    predy.append(0 if pred < 0.5 else 1)
    label.append(data[1])
print("真实标签：", label)
print("预测标签：", predy)
# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CW6w31Yhyxtje3pQWiAfiMg-WU4Je523

# 导包
"""

import numpy as np
import pandas as pd
from graphviz import Digraph

"""# 数据预处理"""

D = pd.read_csv('watermelon.csv')

D.head()

"""# 定义决策树

## 计算信息熵
"""

def get_Ent(D, l):
    # D为数据集，l为标签所在列的名称
    labels = list(set(D[l]))
    Ent = 0
    for label in labels:
        p = len(D[D[l] == label]) / float(len(D))
        if p == 0:
            Ent = 0
        else:
            Ent = Ent + (p)*np.log2(p)
    return -Ent

"""## 计算信息增益

### 计算离散信息增益
"""

def get_discrete_Gain(D, a, l):
    # D为数据集，a为属性值，l为标签所在列的名称
    labels = list(set(D[a]))
    tmp = 0
    for label in labels:
        D_ = D[D[a] == label]
        tmp = tmp + len(D_) / float(len(D)) * get_Ent(D_, l)
    Gain = get_Ent(D, l) - tmp
    return [Gain, -1]

"""### 计算连续信息增益"""

def get_continuous_Gain(D, a, l):
    # D为数据集，a为属性值，l为标签所在列的名称
    T =[]
    for i in range(len(D)-1):
        T.append((np.sort(D[a])[i]+np.sort(D[a])[i+1])/2)
    T = np.sort(T)
    Gains = []
    for t in T:
        Dlow = D[D[a] < t]
        Dup = D[D[a] > t]
        Gain = get_Ent(D, l) - (len(Dlow) / float(len(D)) * get_Ent(Dlow, l) + len(Dup) / float(len(D)) * get_Ent(Dup, l))
        Gains.append(Gain)
    return [np.max(Gains), T[np.argmax(Gains)]]

"""## 寻找信息增益最大的划分数据集的方式"""

def chooseBestSplit(D, A, l):
    continuous = ['密度', '含糖率']
    Gains = []
    for a in A:
        if a in continuous:
            Gains.append(get_continuous_Gain(D, a, l))
        else:
            Gains.append(get_discrete_Gain(D, a, l))
    # bestFeature: 使得到最大增益划分的属性。
    # bestThresh： 使得到最大增益划分的数值。标称型时无意义令其为-1。
    bestFeature = A[(np.argmax(Gains, axis=0))[0]]
    bestThresh = Gains[(np.argmax(Gains, axis=0))[0]][1]
    return bestFeature, bestThresh

"""## 投票"""

def majorityCnt(D, l):
    labels = list(set(D[l]))
    counts = []
    for label in labels:
        count = len(D[D[l] == label])
        counts.append(count)
    return labels[np.argmax(counts)]

"""## 生成决策树"""

def TreeGenerate(D, A, l):
    # 如果D为空，则返回默认值
    if len(D) == 0:
        return '好瓜'
    
    # 如果剩余的类别全相同,则返回
    if len(list(set(D[l]))) == 1:
        return list(set(D[l]))[0]
    
    # 如果只剩下类标签，投票返回
    if len(A) == 0:
        return majorityCnt(D, l)

    # 得到增益最大划分的属性、阈值
    bestFeature, bestThresh = chooseBestSplit(D, A, l)
    
    # 创建属性标注
    if bestThresh != -1: # 如果是连续值
        txt = bestFeature + "<=" + '%.3f'%bestThresh + "?"
    else: # 如果是离散值
        txt = bestFeature + "=" + "?"

    # 创建节点
    myTree = {txt: {}}

    if bestThresh != -1:   # 连续值的话就是左右两个子树。
        subDL, subDR = D[D[bestFeature] < bestThresh], D[D[bestFeature] > bestThresh]
        myTree[txt]['是'] = TreeGenerate(subDL, A, l)
        myTree[txt]['否'] = TreeGenerate(subDR, A, l)
    else: 
        A.remove(bestFeature) # 生成子树的时候要将已遍历的属性删去。数值型不要删除。
        values = list(set(D[bestFeature]))  # 最好的特征的类别列表
        for value in values:    # 标称型的属性值有几种，就要几个子树。
            B = A[:]
            subD = D[D[bestFeature] == value]
            myTree[txt][value] = TreeGenerate(subD,B, l)
    return myTree

"""# 画图"""

root = "0"
def sub_plot(g, tree, inc):
    global root
    first_label = list(tree.keys())[0]
    ts = tree[first_label]
    for i in ts.keys():
        if isinstance(tree[first_label][i], dict):
            root = str(int(root) + 1)
            g.node(root, list(tree[first_label][i].keys())[0], fontname="FangSong")
            g.edge(inc, root, str(i), fontname="FangSong")
            sub_plot(g, tree[first_label][i], root)
        else:
            root = str(int(root) + 1)
            g.node(root, tree[first_label][i], fontname="FangSong")
            g.edge(inc, root, str(i), fontname="FangSong")

def plot_model(tree, name):
    global root
    root = '0'
    g = Digraph(filename=name, format='png')
    first_label = list(tree.keys())[0]
    g.node("0", first_label, fontname="FangSong")
    sub_plot(g, tree, "0")
    g.view()

"""# 主函数"""

A = list(D.columns[:-1]) 
mytree = TreeGenerate(D, A, '好瓜')
plot_model(mytree, "mytree")
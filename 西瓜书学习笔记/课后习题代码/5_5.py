# -*- coding: utf-8 -*-
"""5_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b0F_4NCTwv6rpIrm8_OXeUY_JO2_qAFn

# 导包
"""

from google.colab import drive

import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""# 定义超参数"""

d_input = 8 # 输入层神经元个数
d_hidden = 4 # 隐含层神经元个数
d_output = 1 # 输出层神经元个数

lr = 0.05
epochs = 5000

"""# 数据预处理"""

drive.mount('/content/drive')
df = pd.read_csv('/content/drive//MyDrive/data/tmp/watermelon.csv')
df.head()

feature1 = list(set(df['色泽']))
feature2 = list(set(df['根蒂']))
feature3 = list(set(df['敲声']))
feature4 = list(set(df['纹理']))
feature5 = list(set(df['脐部']))
feature6 = list(set(df['触感']))
label = list(set(df['好瓜']))

feature1toidx = {v: i for i, v in enumerate(feature1)}
feature2toidx = {v: i for i, v in enumerate(feature2)}
feature3toidx = {v: i for i, v in enumerate(feature3)}
feature4toidx = {v: i for i, v in enumerate(feature4)}
feature5toidx = {v: i for i, v in enumerate(feature5)}
feature6toidx = {v: i for i, v in enumerate(feature6)}
labeltoidx = {v: i for i, v in enumerate(label)}

df['色泽']= df['色泽'].replace(feature1toidx)
df['根蒂']= df['根蒂'].replace(feature2toidx)
df['敲声']= df['敲声'].replace(feature3toidx)
df['纹理']= df['纹理'].replace(feature4toidx)
df['脐部']= df['脐部'].replace(feature5toidx)
df['触感']= df['触感'].replace(feature6toidx)
df['好瓜']= df['好瓜'].replace(labeltoidx)
df.head()

x = df[['色泽', '根蒂', '敲声', '纹理', '脐部', '触感', '密度', '含糖率']].values.tolist()
y = df['好瓜'].values.tolist()

dataset = []
for i in range(len(x)):
    data = []
    data.append(x[i])
    data.append(y[i])
    dataset.append(data)

"""# 定义模型"""

def sigmoid(x):
    y = []
    for i in x:
       y.append(1 / (1 + np.exp(-i)))
    return np.array(y)

class NN():
    def __init__(self):
        self.v = np.random.randn(d_input, d_hidden) # 连接输入层隐含层的权重矩阵
        self.w = np.random.randn(d_hidden, d_output) # 连接隐含层到输出层的权重矩阵
        self.gamma = np.random.randn(d_hidden)   # 隐含层阈值
        self.theta = np.random.randn(d_output)   # 输出层阈值
    
    def train(self, data, test=False):
        # 读取数据
        x = np.array(data[0]).reshape((1, len(data[0])))
        y = data[1]

        # 预测结果
        a = np.dot(x, self.v)
        b = sigmoid((a - self.gamma)[0])
        c = np.dot(b, self.w)
        pred = sigmoid(c - self.theta)

        # 计算误差
        loss = 0.5 * (pred - y)*(pred - y)

        # 测试时不用更新参数
        if test == False:
            # 更新参数
            g = pred * (1 - pred) * (y - pred)
            e = b * (1 - b) * ((np.dot(self.w, g)))

            self.w = self.w + lr * np.dot(b.reshape((d_hidden, 1)), g.reshape(1,d_output))
            self.theta = self.theta - lr * g
            self.v = self.v + lr * np.dot(x.reshape((d_input, 1)), e.reshape((1, d_hidden)))
            self.gamma = self.gamma - lr * e
        return pred, loss

"""# 训练模型"""

model = NN()
loss = []
for i in range(epochs):
    lo = []
    random.shuffle(dataset)
    for data in dataset:
        _, l = model.train(data)
        lo.append(l)
    loss.append(np.mean(lo))

"""# 可视化loss"""

plt.figure()
plt.plot(loss)
plt.xlabel('step')
plt.ylabel('loss')
plt.show()

"""# 预测"""

label, predy = [], []
for data in dataset:
    pred, _ = model.train(data, test=True)
    predy.append(0 if pred < 0.5 else 1)
    label.append(data[1])
print("真实标签：", label)
print("预测标签：", predy)